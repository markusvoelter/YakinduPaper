\section{Introduction}

\subsection{Context}

Embedded Software is getting more and more important in many products
It also getting more and more complex
Time to Market is becoming shorter and shorter
Effectiveness and Efficiency have to be increased

Implementing a System in C only is not productive enough
C is low level, dangerous, etc.
Hence, modeling tools have been broadly adopted in ES
For a real world-system, many different modeling paradigms
  are useful -> Multiparadigm Modeling

Currently, modeling tools either
* address only one paradigm, leading to integration challenges
  (Simulink et al.)
* provide many many paradigms that are hard to extend and 
  overwhelm the user (UML)
* or are completely open and anything has to be built  
  from scratch (LWBs) 


\subsection{Challenges}  
If several different paradigms are used, these have to be integrated
  a single modeling tool
-> tools need to be open and extensible in meaningful ways

Some aspects of a domain can be expressed with existing, 
  reusable paradigmes; for others, we need DS abstractions
-> how can existing paradigms be made reusable in a modular way

Even for these reusable paradigms, there are parts that need to
  be adapted in a domain-specific way
-> how can reusable paradigms be extended to include DS parts?


\subsection{Contribution}
We clearly identify areas in ES that can be address with reusable
  paradigms; and we identify these paradigms
We identify places where DS abstractions can be benefitial
We show how DS and reusable stuff can be integrated in a meaningful way
We demonstrate the approach using an Eclipse based tool called Yakindu
We use real-world industry examples to demonstrate the approach
 
\subsection{Structure of the Paper}

the boundaries between reusable abstractions 
  and DS abstractions and how they can be conceptually combined
  
  



Problem
Today's embedded software modeling tools have problems:
- Not Extensible in domain-specific ways
- Often one-paradigm-per tool -> ijtegratiion
- Bad Support for Process Issues (PLE, Tracing)
- Practices of SW Eng (Interface vs.Impl, Specialization, Modualization)
  not very well supported
  
SOlution with Yakindu
A set of predefined commonly used modeling paradigms that can be 
extended in domain-specific ways, and making use of state of the art
sw eng techniques. 

Particularly:
- Components, State Machines, Block Diagrams
- ... as modules for custom tools, or in an integrated suite
- with DSLs for actions and blocks that can be interpreted 
  (for sim) and generated (to several langs)
- extensible via custom DSLs in actions, blocks
- new DSLs can be "attached" via referencing

Multi-Paradigm in the sense that
- states and blcocks and code
- graphical and textual
- declarative DSL in blocks
- within states and blocks: other 

Sw-Eng
- Roles: block implementers vs. block wireres
- inheritance, specialization
- blocks: sep of ctrl flow vs. data flow
- tooling: generator anpassen; interpreter und generator; zwieshcnemodell
- semantik anpassebar

Process Issues
- TRaceability: RMF, Crema
- PLE: (da fehlt noch was :-))

Example: HMI Stuff as an instance/DS-adaptation of the tool chain

    